# 从 “Create a Claw” 到 Rust + SQLite：我是怎么做这个 Agent 项目的

## 起点

我看到 [Create a Claw](https://frostming.com/posts/2026/create-a-claw/) 后，决定做一个自己的本地 Agent。  
我的目标不是先做大框架，而是先做一个最小可运行系统，再让它逐步自举扩展。

## 我的决策时间线

## 1. 先把运行环境打通：OrbStack / Docker

我先确认本机环境，再安装容器运行时，最终选择 OrbStack（Docker 兼容）。

我这么选的原因：

1. 个人开发体验更轻量。
2. 仍然可以完全沿用 Docker CLI 和镜像工作流。

## 2. 先在容器外验证 Telegram API

我没有一上来就放进容器，而是先在宿主机验证：

1. `getMe`：token 是否有效。
2. `getUpdates`：能不能拉到消息。
3. `sendMessage`：能不能回消息。

这样可以先把 API 问题和容器问题分开，排障效率更高。

## 3. 先用脚本打通主链路

我先做了最小轮询脚本，然后收敛到一个 `startup.sh`，先打通：

`Telegram -> startup -> codex exec -> Telegram`

这个阶段的核心是“先跑通”，不是“一次性设计完美架构”。

## 4. 密钥管理和代码仓库严格隔离

我从一开始就坚持这个原则：密钥不能进仓库，也不能写进镜像层。

我的做法是：

1. 密钥放在宿主机环境文件里。
2. 容器启动时注入环境变量。
3. 仓库只保留示例配置，不保留真实值。

这让我后续新增 API key 时不需要重建 image，只需要重建容器实例。

## 5. 我遇到的关键问题：无历史上下文

我发现单次 `codex exec` 默认是无状态调用。  
这意味着如果不额外保存历史，Agent 无法理解依赖前文的指令。

所以我把“历史上下文”定义成核心能力，而不是可选优化。

## 6. 为什么我不继续把 Bash 写大

我实践后确认 Bash 的边界很明确：

1. 做入口和进程拉起很合适。
2. 做复杂状态机和业务逻辑会快速失控。

因此我决定把 Bash 缩到最小，只保留 startup/supervisor 角色，把主 loop 迁到 Rust。

## 7. 为什么我现在选 Rust（而不是直接 Elixir）

我认真比较了 Go / Rust / Elixir，最后当前阶段先用 Rust：

1. 我不追求短期里程碑速度，更看重长期可维护性。
2. Rust 的类型系统和编译反馈对“可自修改系统”更友好。
3. 现在仍是单容器 MVP，直接上 Elixir 会把分布式复杂度提前。

我的阶段性策略是：先把核心 loop 做硬，未来多 Agent 协作再评估引入 Elixir。

## 8. 为什么我把历史存储选成 SQLite

我没有选纯文本文件，也没有一开始上外部数据库，而是选 SQLite：

1. 单文件、零运维，最适合本地启动期。
2. 查询和筛选能力足够支持“最近 N 轮上下文”拼装。
3. 事务一致性比手工文件锁可靠。
4. 未来迁移到 Postgres 等数据库时路径清晰。

这对当前阶段是“最小复杂度 + 足够可靠性”的平衡点。

## 9. 把“怎么做”写进仓库，而不是写死在容器里

我后来补上了一个关键实践：

1. 容器运行时挂载本地仓库目录。
2. 在仓库根目录维护 `AGENTS.md` 作为 Agent 执行说明。
3. 让容器内 Agent 通过读取仓库中的说明，理解当前目标、边界和工作方式。

这个设计的意义是：
- 我不需要频繁改镜像来“教”Agent 新规则。
- 规则和代码一起版本化，演进可追踪。
- 容器内外看到的是同一份事实来源。

## 10. 我的基础镜像和最小工具集

基础镜像我定为 `debian:bookworm-slim`。  
工具集我明确做减法：

1. 保留：`bash`, `curl`, `git`, `jq`, `sqlite3`, `libsqlite3-dev`, Rust toolchain, Codex CLI
2. 移除：`python3`（避免把简单问题无谓地转成 Python 脚本）

## 我接下来的实现顺序

基于以上决策，我的下一步是：

1. 实现 Rust 最小 Agent Loop（Telegram long polling + reply）。
2. 用 SQLite 落地按 chat/session 的历史。
3. 给 Codex 调用层加“历史上下文注入”。
4. 把 `startup.sh` 固化为最小 supervisor，不再承载业务逻辑。

做到这里，我的项目就从“脚本演示”进入“可持续演化的内核”阶段。
